
BASIC:

    class application
    (cond ((if1 then1)
           (if2 => then2withresult)))
    (object? foo)
    (split rx/\s+/ str)
    (hash->pairs h)
    (pairs->hash)
    (pairs->list)
    (list->pairs)
    (pairs->hash ps)
    (begin ...)
    (matches? rx/rx/ str)
    (match rx/rx/ str)
    (match-all rx/rx/ str)
    (replace rx/rx/ fun str)
    (regex rx1 rx2 ...)
    (error "invalid something")
    (catch (λ () ...) (λ (e) ...))
    (thunk ...)
    (for `(1 2 3) say)
    (quotemeta str1 str2 ...)
    (curry fun 1 2 ...)
    (rcurry fun 1 2 ...)
    (# ...)
    (while defined? 
           (thunk (rs :next))
           (-> (say "name: " (_ :name))))
    
    ; should work
    ; die if reserved var name passed in
    (let ((let 23))
      (+ let let))

    (module 
      (arguments:   foo bar baz . optional arg)
      (exports:     x1 x2 (group: x3 x4))
      (libraries:   Core))
    (import "foo/bar.sx" { foo: 23 } :all)
    (include "foo/bar.sx" { bar: 23 })

    (import-types
      (Moose        (Str as: MooseStr) ArrayRef HashRef)
      (Path::Class  File Dir))
    (define StrList (ArrayRef Str))
    (coerce value MyType)
    (is? value MyType)
    (define Foo (subtype Int where: odd?))
    (define-subtype Foo as: Int where odd?)
    (assert Type value) ; blows up if fail

    (lambda ([Str n] [Int m]) (list n m))




OBJECTS:

    ???




EXTENDED


    (# ...)
    (with-input-from *in* ...)
    (zip fun ls1 ls2 ls3 ...)
    (unzip ls fun)
    (meta-of obj)
    (env 'HOME)
    (partition ls fun-returning-str)
    (with-output-to *out* ...)
    (with-errors-to *err* ...)
    (with-input-from-string str ...)
    (with-output-to-string str ...)
    (with-error-to-string str ...)
    (with-default-input ...)
    (with-default-output ...)
    (say ...)
    (print ...)
    (read ...)
    (if-value foo
      (== (1 "one")
          (2 "two")
          (3 "hree"))
      (<  (10 "not ten")
          (20 "not twenty"))
      (else "twenty or more"))
    (let-named (foo x)
      (if (== x 0)
        (say "zero")
        (foo (-1 x))))
    (lambda-case
      ((x) x)
      ((x y) (+ x y))
      (args (apply * args)))















    
