
BASIC:

    quoting
    hash
    array
    /foo\/bar/
    (let
    (let*
    (let-rec
    (define (foo x y)
    booleans
    keywords
    () equal to []
    (set! x 23)
    (map ls f)
    (grep ls f)
    (list ...)
    (hash ...)
    (cond ((if1 then1)
           (if2 => then2withresult)))
    (object? foo)
    (hash? bar)
    (list? baz)
    (empty? ...) ; (), {}, '', undef
    (join sep ls)
    (split /\s+/ str)
    (apply + x y (list y z))
    (append ls1 ls2)
    (== 1 2)
    (eq? "x" "y")
    < > <= >=
    <=>
    (sort ls fun)
    and, and-def, 
    or, or-def, 
    not, not-def,
    (any? '(1 2 3) odd?)
    (all? '(2 3 4) (-> (< _ 10)))
    (one? ls fun)
    (none? ls fun)
    (first ls f)
    (hash-map hs f)
    (hash-grep hs f)
    (hash->pairs h)
    (pairs->hash ps)
    (flatten h1 h2 a1 a2)
    (head ls)
    (tail ls)
    (zip fun ls1 ls2 ls3 ...)
    (unzip ls fun)
    (keys hs)
    (keys ls)
    (values hs)
    (values ls)
    (string s1 s2 s3 ...)
    (partition ls fun-returning-str)
    (reduce ls fun)
    (unless cond then alter)
    (begin ...)
    (matches? /rx/ str)
    (match /rx/ str)
    (match-all /rx/ str)
    (replace /rx/ fun str)
    (curry fun 1 2 ...)
    (rcurry fun 1 2 ...)
    (uniq ls ...)
    (gather (lambda (foo) (foo 5)))
    (while defined? (row (rs :next))
      (say (at row :name)))
    turn () '() [] '[] into empty list
    (meta-of obj)
    Î»
    (min ...)
    (max ...)
    (env 'HOME)
    
    ; should work
    ; die if reserved var name passed in
    (let ((let 23))
      (+ let let))




EXTENDED

    (# ...)
    (-> (* _ 2))
    (at hash :foo 0)            ; getter, returns accessor handler for set!
    (set! (at ...) ...          ; setter
    (with-input-from *in* ...)
    (with-output-to *out* ...)
    (with-errors-to *err* ...)
    (with-input-from-string str ...)
    (with-output-to-string str ...)
    (with-error-to-string str ...)
    (with-default-input ...)
    (with-default-output ...)
    (say ...)
    (print ...)
    (read ...)
    (if-value foo
      (== (1 "one")
          (2 "two")
          (3 "hree"))
      (<  (10 "not ten")
          (20 "not twenty"))
      (else "twenty or more"))
    (let-named (foo x)
      (if (== x 0)
        (say "zero")
        (foo (-1 x))))
    (import "foo.sx" '(foo bar))
    (include "bar.inc.sx")
    (module "foo/bar" (exports foo bar) (receives baz qux))
    (export foo bar)
    (lambda-case
      ((x) x)
      ((x y) (+ x y))
      (args (apply * args)))















    
