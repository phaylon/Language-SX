
BASIC:

    (cond ((if1 then1)
           (if2 => then2withresult)))

    (object? foo)

    (error "invalid something")
    (catch (λ () ...) (λ (e) ...))

    (import-types
      (Moose        (Str as: MooseStr) ArrayRef HashRef)
      (Path::Class  File Dir))
    (define StrList (ArrayRef Str))
    (coerce value MyType)
    (is? value MyType)
    (define Foo (subtype Int where: odd?))
    (define-subtype Foo as: Int where odd?)
    (assert Type value) ; blows up if fail

    (lambda ([Str n] [Int m]) (list n m)) ; arg type check

    (let (([Int x] 23)) x)  ; ret type check

    ((class-invocant "Foo") 'new x: 3 y: 4)
    (call-in-list-context (class-invocant "Foo") :some-list 2 3 4)
    (call-in-list-context applicant arg1 arg2 ...)

    (stepper->iterator (-> (if (> _ 10) #f (++ _))) 0)
    (range->iterator 0 1000)
    (keys->iterator comp)
    (values->iterator comp)

    (iterate (range-iterator 1 10)
      (-> (* _ 2))
      (it-filter even?)
      (it-replace
        (lambda (value)
          (map (range 0 3) (-> _ value)))))

    (range 0 10)





    (Dict foo: (ArrayRef Int)
          bar: (Tuple Str Str HashRef))






OBJECTS:

    ???



HTML PROCESSOR:

    maybe: (uri-for-action /foo/bar: captures params 1 2 3)

    (define (wrapper page)
      `(html
        (head
          (title (at page :title))
          (link { rel: "stylesheet" href: ,(uri-for-action "/static" "base.css") }))
        (body
          (table { id: "content" }
            (tr (td { id: "header" }
                  (h1 ,(at page :ttile))))
            (tr (td { id: "body" }
                  ,(at page :content)))
            (tr (td { id: (raw! "footer") }
                  (raw! greeting)
                  "You can email me at "
                  ,(hidden-email (at page :contact))))))))

        






EXTENDED


    (with-input-from *in* ...)
    (zip fun ls1 ls2 ls3 ...)
    (unzip ls fun)
    (meta-of obj)
    (env 'HOME)
    (partition ls fun-returning-str)
    (with-output-to *out* ...)
    (with-errors-to *err* ...)
    (with-input-from-string str ...)
    (with-output-to-string str ...)
    (with-error-to-string str ...)
    (with-default-input ...)
    (with-default-output ...)
    (say ...)
    (print ...)
    (read ...)
    (cmp-value foo
      (== (1 "one")
          (2 "two")
          (3 "hree"))
      (<  (10 "not ten")
          (20 "not twenty"))
      (else "twenty or more"))
    (if-value foo
      (Int (* 2 foo))
      (Str (string foo foo))
      (Any (error 'gnarf)))
    (let-named (foo x)
      (if (== x 0)
        (say "zero")
        (foo (-1 x))))
    (lambda-case
      ((x) x)
      ((x y) (+ x y))
      (args (apply * args)))















    
